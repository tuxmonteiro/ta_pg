import xml.etree.ElementTree as ET
import os

def generate_pg_tests(xml_file, output_file):
    tree = ET.parse(xml_file)
    root = tree.getroot()

    with open(output_file, 'w') as f:
        f.write("""
# This file is generated by scripts/generate_pg_tests.py. Do not edit manually.
# These tests are basic and only verify that the functions can be called without errors.
# They do not validate the correctness of the output.

import pytest
import psycopg2
import os
import numpy as np

@pytest.fixture(scope='module')
def db_conn():
    dbname = os.environ.get('PGDATABASE', 'testdb')
    user = os.environ.get('USER', 'postgres')
    host = os.environ.get('PGHOST', 'localhost')
    port = os.environ.get('PGPORT', '5432')
    password = os.environ.get('PGPASSWORD', 'secret')

    conn_str = f"dbname='{dbname}' user='{user}' host='{host}' port='{port}' password='{password}'"
    
    print(f"Connecting with: {conn_str}")

    try:
        conn = psycopg2.connect(conn_str)
        yield conn
        conn.close()
    except psycopg2.OperationalError as e:
        pytest.skip(f"Could not connect to PostgreSQL: {e}")

@pytest.fixture(scope='module', autouse=True)
def setup_extension(db_conn):
    with db_conn.cursor() as cursor:
        cursor.execute("CREATE EXTENSION IF NOT EXISTS ta_pg")
    db_conn.commit()
    yield
    with db_conn.cursor() as cursor:
        cursor.execute("DROP EXTENSION IF EXISTS ta_pg")
    db_conn.commit()

""")

        for func in root.findall('FinancialFunction'):
            abbreviation = func.find('Abbreviation').text
            sql_func_name = f"ta_{abbreviation.lower()}"
            
            required_inputs = func.find('RequiredInputArguments').findall('RequiredInputArgument')
            optional_inputs_element = func.find('OptionalInputArguments')
            optional_inputs = optional_inputs_element.findall('OptionalInputArgument') if optional_inputs_element is not None else []
            outputs = func.find('OutputArguments').findall('OutputArgument')

            f.write(f"def test_{sql_func_name}(db_conn):\n")
            
            # Prepare input data
            f.write("    # Prepare input data\n")
            f.write("    open_ = np.random.random(100) * 100\n")
            f.write("    high = open_ + np.random.random(100) * 10\n")
            f.write("    low = open_ - np.random.random(100) * 10\n")
            f.write("    close = (high + low) / 2\n")
            f.write("    volume = np.random.random(100) * 1000\n")
            f.write("    inreal = np.random.random(100) * 100\n")
            f.write("    inreal0 = np.random.random(100) * 100\n")
            f.write("    inreal1 = np.random.random(100) * 100\n")

            # Construct the SQL query
            f.write("    # Construct the SQL query\n")
            
            sql_params = []
            for i, req_input in enumerate(required_inputs):
                input_type = req_input.find('Type').text
                if 'Price' in input_type or 'Real' in input_type or 'Double' in input_type or 'High' in input_type or 'Low' in input_type or 'Close' in input_type or 'Open' in input_type or 'Volume' in input_type:
                    sql_params.append(f"%s::double precision[]")
                elif input_type == 'Integer':
                    sql_params.append(f"%s::integer[]")

            opt_sql_params = []
            for opt_input in optional_inputs:
                opt_name = opt_input.find('Name').text.lower().replace(' ','_').replace('-','_')
                opt_sql_params.append(f"{opt_name} => %s")
            
            query_params = sql_params
            if opt_sql_params:
                query_params.extend(opt_sql_params)

            f.write(f"    query = f'SELECT * FROM {sql_func_name}({', '.join(query_params)})'\n")

            # Execute the query
            f.write("    # Execute the query\n")
            f.write("    with db_conn.cursor() as cursor:\n")
            
            f.write("        params = []\n")
            for i, req_input in enumerate(required_inputs):
                input_type = req_input.find('Type').text
                input_name = req_input.find('Name').text.lower().replace(' ','_').replace('-','_')
                
                if input_name == 'open': # Special case for 'open' to avoid conflict with built-in
                    f.write(f"        params.append(open_.tolist())\n")
                elif input_name == 'high':
                    f.write(f"        params.append(high.tolist())\n")
                elif input_name == 'low':
                    f.write(f"        params.append(low.tolist())\n")
                elif input_name == 'close':
                    f.write(f"        params.append(close.tolist())\n")
                elif input_name == 'volume':
                    f.write(f"        params.append(volume.tolist())\n")
                elif input_name == 'inreal':
                    f.write(f"        params.append(inreal.tolist())\n")
                elif input_name == 'inreal0':
                    f.write(f"        params.append(inreal0.tolist())\n")
                elif input_name == 'inreal1':
                    f.write(f"        params.append(inreal1.tolist())\n")
                elif 'Integer' in input_type:
                    f.write(f"        params.append(np.random.randint(0, 100, 100).tolist())\n")
                elif 'Double' in input_type:
                    f.write(f"        params.append(np.random.random(100).tolist())\n")

            for opt_input in optional_inputs:
                default_value = opt_input.find('DefaultValue').text
                f.write(f"        params.append({default_value})\n")

            f.write(f"        cursor.execute(query, params)\n")
            f.write("        result = cursor.fetchone()\n")
            
            # Assert the result
            f.write("    # Assert the result\n")
            f.write("    assert result is not None\n")
            if len(outputs) > 1:
                f.write(f"    assert len(result) == {len(outputs)}\n")
            f.write("\n\n")

if __name__ == "__main__":
    generate_pg_tests('./ta-lib/ta_func_api.xml', './src/tests/test_ta_pg.py')
